<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8"/>
        <title>RACE</title>

        <link href="../race-html.css" rel="stylesheet"/>
    </head>

    <body>
        <div class="navbar">
            <div class=""banner>
                <a href="../index.html" ><img class="logo" src="../images/race128.png"></a>
                <p class="doctitle">RACE Manual</p>
            </div>
            <br/>
            <div class="toc">
                <p class="title">Project Links</p>
                <ul>
                    <li><span class="toc level2"><a href="https://github.com/NASARace/race.git">Repository</a></span></li>
                    <li><span class="toc level2"><a href="http://nasarace.github.io/race">Website</a></span></li>
                </ul>
            </div>
            <div class="toc pagetoc">
                <p class="title">Page</p>
                <ul class="nav-list">
                  <li class="level1 active"><a href="#">HttpServer</a></li>
                  <li class="level2"><a href="#encrypted-content">Encrypted Content</a></li>
                  <li class="level2"><a href="#user-authentication">User Authentication</a></li>
                  <li class="level2"><a href="#websocket-support">WebSocket Support</a></li>
                  <li class="level2"><a href="#serving-mixed-static-and-dynamic-content">Serving Mixed Static and Dynamic Content</a></li>
                  <li class="level2"><a href="#test-routes">Test Routes</a></li>
                </ul>
            </div>
            <div class="toc globaltoc">
                <p class="title">Site</p>
                <ul class="nav-list">
                  <li class="level1 nav-header">RACE Manual</li>
                  <li class="level2"><a href="../index.html">About RACE</a></li>
                  <li class="level2 nav-header">Installing RACE</li>
                  <li class="level3"><a href="../installation/prerequisites.html">Prerequisites</a></li>
                  <li class="level3"><a href="../installation/download.html">Downloading RACE</a></li>
                  <li class="level3"><a href="../installation/build.html">Building RACE</a></li>
                  <li class="level3"><a href="../installation/pitfalls.html">Installation Pitfalls</a></li>
                  <li class="level3"><a href="../installation/osx.html">OS X Specifics</a></li>
                  <li class="level2 nav-header">Using RACE</li>
                  <li class="level3"><a href="../usage/running.html">How to Run RACE</a></li>
                  <li class="level3"><a href="../usage/configuration.html">RACE Configuration</a></li>
                  <li class="level3"><a href="../usage/encryption.html">Using Encrypted Configurations</a></li>
                  <li class="level2 nav-header">RACE Design</li>
                  <li class="level3"><a href="overview.html">Design Overview</a></li>
                  <li class="level3"><a href="actors.html">Actors</a></li>
                  <li class="level3"><a href="configuration.html">Runtime Configuration</a></li>
                  <li class="level3"><a href="raceactors.html">RaceActors</a></li>
                  <li class="level3"><a href="channeltopics.html">ChannelTopics</a></li>
                  <li class="level3"><a href="embedded-objects.html">Embedded Objects</a></li>
                  <li class="level3"><a href="connectivity.html">Connecting External Systems</a></li>
                  <li class="level3"><a href="remoting.html">Remote RaceActors and Distributed RACE Applications</a></li>
                  <li class="level3"><a href="remotelauncher.html">RemoteLauncher</a></li>
                  <li class="level3"><a href="hc.html">Heterogeneous Computing in RACE</a></li>
                  <li class="level3"><a href="parsing.html">RACE Parsers</a></li>
                  <li class="level3"><a href="archive-replay.html">Archive and Replay</a></li>
                  <li class="level3"><a href="timeseries.html">Time Series Analysis</a></li>
                  <li class="level3"><a href="trajectory.html">Trajectory Infrastructure</a></li>
                  <li class="level3"><a href="rgis.html">RACE GIS Support</a></li>
                  <li class="level3"><a href="worldwind.html">WorldWind Viewer</a></li>
                  <li class="level3 active"><a href="#">HttpServer</a></li>
                  <li class="level3"><a href="http-client.html">HttpImportActor</a></li>
                  <li class="level3"><a href="share.html">SHARE - System for Hierarchical Ad hoc Reporting</a></li>
                  <li class="level3"><a href="layers-and-modules.html">Layers and Modules</a></li>
                  <li class="level3"><a href="directory-structure.html">Directory Structure</a></li>
                  <li class="level3"><a href="repository.html">Repository Structure</a></li>
                  <li class="level3"><a href="local-build.html">Local Build Configuration</a></li>
                  <li class="level3"><a href="dds.html">RACE and DDS</a></li>
                  <li class="level3"><a href="extproject.html">Using RACE from External Projects</a></li>
                  <li class="level3"><a href="whyscala.html">Why Scala</a></li>
                  <li class="level2 nav-header">Documentation</li>
                  <li class="level3"><a href="../documentation/overview.html">RACE Documentation Overview</a></li>
                  <li class="level3"><a href="../documentation/presentations.html">Available Slide Presentations</a></li>
                  <li class="level2 nav-header">Annex</li>
                  <li class="level3"><a href="../annex/project-log.html">Project Log</a></li>
                  <li class="level3"><a href="../annex/examples.html">RACE Examples</a></li>
                  <li class="level3"><a href="../annex/known-problems.html">Known Problems</a></li>
                  <li class="level3"><a href="../annex/changes.html">Changes</a></li>
                  <li class="level3"><a href="../annex/todo.html">TODO List</a></li>
                  <li class="level3"><a href="../annex/learning.html">Learning Resources</a></li>
                  <li class="level3"><a href="../annex/glossary.html">Glossary</a></li>
                </ul>
            </div>
        </div>

        <div class="main">
            <h1 id="httpserver" class="title">HttpServer</h1>
            <p>One of the use cases of RACE is to analyze large data streams and make results available online,
            i.e. outside of RACE. To support external clients RACE includes the <code>gov.nasa.race.http.HttpServer</code>,
            which is a low- to mid-level traffic web server that can be configured with <code>RaceRouteInfo</code> objects,
            to turn data received from RACE channels into web content and map it to URIs, supporting dynamic refresh,
            user authentication, logging and more.</p>
            <p>To that end <code>HttpServer</code> has two major functions:</p>
            <ul>
              <li>routing - mapping trees of URIs to content and http methods)</li>
              <li>content management - creating and retrieving web content</li>
            </ul>
            <p>For routing <code>HttpServer</code> leans heavily on the <a href="https://doc.akka.io/docs/akka-http/current/scala/http/">AkkaHttp</a> library, which provides a full
            <a href="https://doc.akka.io/docs/akka-http/current/scala/http/routing-dsl/index.html">DSL</a> to hierarchically define URI systems with interspersed processing elements such as
            <a href="https://tools.ietf.org/html/rfc2616">HTTP</a> method matchers, cookie checks and path combinators. The DSL itself is beyond the scope of this
            document,nhere we just note that each configured <code>RaceRoutInfo</code> can provide its own <code>route()</code>
            method that returns a <code>akka.http.scaladsl.server.Route</code> object.</p>
            <p><img class="center scale90" src="../images/http-server.svg" alt="HttpServer"></p>
            <p><code>RaceRouteInfo</code> is the construct that ties data acquisition, content creation and content/route
            association together. Each <code>HttpServer</code> instance can be configured with any number of
            <code>RaceRouteInfo</code> objects, which in turn can have their own configuration parameters. The design is
            similar to <code>RaceViewerActor</code> and <code>RaceLayerInfos</code> (see <a href="worldwind.html#worldwind-viewer">WorldWind Viewer</a>).</p>
            <p>Data acquisition required to generate query responses is handled through dedicated actors that are
            associated with their corresponding <code>RaceRouteInfos</code>. Such actors extend <code>SubscribingRaceActor</code>
            and turn data received from the subscribed channels into <code>HttpContent</code> objects (aggregation of
            HTML page and associated resources such as images etc.). The <code>HttpContent</code> is stored in
            <code>RaceRouteInfo</code> and referenced from within its <code>route()</code> method to generate the response for
            valid HTTP requests.</p>
            <p>There is no restriction what type of content can be supported by <code>RaceRouteInfos</code> (html, json
            etc.). For HTML content creation we use the <a href="http://www.lihaoyi.com/scalatags/">ScalaTags</a> library, which provides a DSL that supports
            procedural elements in a tree that is very close to the created HTML structure. Akka-http also
            supports bi-directional communication by means of <a href="https://doc.akka.io/docs/akka-http/current/server-side/websocket-support.html">WebSockets</a>.</p>
            <p>The <code>gov.nasa.race.http.Test{RouteInfo,Authorized,Refresh}</code> examples show how define routes and
            (self refreshing) HTML content.:</p>
            <pre><code>//--- basic RaceRouteInfo example
class TestRouteInfo (val parent: ParentContext, val config: Config) extends RaceRouteInfo {
  val request = config.getStringOrElse(&quot;request&quot;, &quot;test&quot;)
  val response = config.getStringOrElse(&quot;response&quot;, &quot;Hello from RACE&quot;)

  override def route = {
    path(request) {
      get {
        complete(HttpEntity(ContentTypes.`text/html(UTF-8)`, response))
      }
    }
  }
}

//--- example of how to implement authorized content for configured paths
class TestAuthorized (val parent: ParentContext, val config: Config) extends AuthorizedRaceRoute {
  val request = config.getStringOrElse(&quot;request&quot;, &quot;secret&quot;)
  var count = 0
  def page = html(
    body(
      nid(s&quot;the supersecret answer #$count to the ultimate question of life, the universe and everything is:&quot;),
      nid(b(&quot;42&quot;)),
      nid(&quot;(I always knew there was something wrong with the universe)&quot;),
      logoutLink
    )
  )

  override def route = {
    path(request) {
      get {
        count += 1
        completeAuthorized(User.UserRole, HttpEntity(ContentTypes.`text/html(UTF-8)`, page.render))
      }
    }
  }
}</code></pre>
            
            <h2 id="encrypted-content" class="section"><a class="anchor-link left" href="#encrypted-content"><i class="icofont-laika">&#xef71;</i></a>Encrypted Content</h2>
            <p><code>HttpServer</code> can be configured to use the <a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS</a> protocol for server authentication and
            content encryption:</p>
            <pre><code>...
use-https = true
server-keystore = &quot;??server.keystore&quot;
server-keystore-pw = &quot;??server.pw&quot;
...</code></pre>
            <p>If <code>use-https</code> is set a valid <a href="https://lightbend.github.io/ssl-config/CertificateGeneration.html">X.509 certificate</a> keystore has to be provided, which can for
            instance be generated by means of the JDK <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html">keytool</a>. Location path and passphrase values should be kept
            in a vault (see <a href="configuration.html#encrypted-configurations">Encrypted Configurations</a>) like this:</p>
            <pre><code>...
server {
    keystore=&quot;../cert/localhost.jks&quot;
    pw=&quot;mysupersecretpassphrase&quot;
    ...
}</code></pre>
            <p>For testing purposes a keystore can be created by running the <code>script/gen-server-cert.sh</code> script.
            To generate a self-signed CA certificate we provide <code>script/gen-ca-cert.sh</code>.</p>
            
            <h2 id="user-authentication" class="section"><a class="anchor-link left" href="#user-authentication"><i class="icofont-laika">&#xef71;</i></a>User Authentication</h2>
            <p>If content requires user authentication the respective <code>RaceRouteInfo</code> can be derived from
            <code>AuthorizedRaceRoute</code> or <code>AutoAuthorizedRaceRoute</code>, which both provide a <code>completeAuthorized</code>
            directive that is used instead of <code>complete</code> when defining the route:</p>
            <pre><code>...
override def route = {
  get {
    path(&quot;secretData&quot;) {
      completeAuthorized(User.UserRole){
        generateResponse
      }
    }
  }
}</code></pre>
            <p><code>AuthorizedRaceRoute</code> is used for interactive clients and automatically redirects to/from a
            login web page the first time the content is accessed. <code>AutoAuthorizedRaceRoute</code> is for automated,
            non-interactive web clients and requires explicit login/logout requests from the client application.</p>
            <p>User authentication is done by means of challenge/response cookies, i.e. after successful user
            login <code>HttpServer</code> transmits a cookie in the response (via <code>Set-Cookie</code> header) that has to
            be included in the next request from the client. Each accepted response yields a new cookie value,
            i.e. each cookie is only good for the next request and is not permanently stored on the client side:</p>
            <p><img class="center scale90" src="../images/server-auth.svg" alt="server side user authentication"></p>
            <p>A session cookie can also have an expiration date after which the <code>HttpServer</code> will reject it.</p>
            <p>User authentication requires an additional <code>user-auth</code> route configuration option to specify the
            respective password store to use:</p>
            <pre><code>...
use-https = true
server-keystore = &quot;??server.keystore&quot;
server-keystore-pw = &quot;??server.pw&quot;

routes = [
  ...
  { name = &quot;secretData&quot;
    class = &quot;gov.nasa.race.http.TestAutoAuthorized&quot;
    request = &quot;secretData&quot;
    user-auth = &quot;??server.users&quot;
  }
]</code></pre>
            <p>Again, the value for this option should be kept in a encrypted config. Since the password is
            transmitted in the login request data respective routes have to use https.</p>
            <p>This user authentication protocol is also supported by the <a href="http-client.html#httpimportactor">HttpImportActor</a></p>
            
            <h2 id="websocket-support" class="section"><a class="anchor-link left" href="#websocket-support"><i class="icofont-laika">&#xef71;</i></a>WebSocket Support</h2>
            <p>RaceRoutes support the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSocketAPI</a> by means of a number of the <code>PushWSRaceRoute</code>, <code>ProtocolWSRaceRoute</code> and
            <code>AuthorizedWSRoute</code> which provide a <code>promoteToWebSocket()</code> method that can be used from within concrete <code>route()</code>
            implementations like this:</p>
            <pre><code>...
override def route = {
  get {
    path(&quot;ws&quot;) {
      promoteToWebSocket
    }
  }
}</code></pre>
            <p>RACE web sockets come in two flavors: <em>push mode</em> and <em>protocol mode</em>:</p>
            <p><strong>Push mode</strong> sends the same data to all connected clients, supporting per-client initialization by means of overriding
            a <code>initializeConnection()</code> method in respective route implementations, which mix in <code>PushWSRaceRoute</code> and normally
            use associated <code>DataConsumerRaceActors</code> to collect data to publish from configured RACE channels. Such actors use
            the <code>PushWSRaceRoute.setData()</code> method to initiate publishing. Note that this method has to take care of proper
            synchronization in case the data to be pushed is not invariant as the actor and the route object execute in different
            threads. It is up to individual routes to decide where/if RACE data gets translated into published content (such
            as HTML documents), but convention is to use invariant, representation agnostic data as <code>setData()</code> arguments.
            perform the translation once in the respective RaceRouteInfo from within that <code>setData()</code> implementation and then
            serve that cached content from within the <code>route()</code> implementation</p>
            <p>In <strong>protocol mode</strong> the server route responds individually to client requests that are issued as messages sent through
            an established web socket connection. The route implementation has to provide a <code>handleMessage</code> partial function that
            defines the protocol. A simple echo service works like this:</p>
            <pre><code>...
override protected val handleMessage: PartialFunction[Message,Iterable[Message]] = {
  case tm: TextMessage.Strict =&gt;
    val msgText = tm.text
    TextMessage(Source.single(s&quot;Echo [$msgText]&quot;)) :: Nil
}</code></pre>
            
            <h2 id="serving-mixed-static-and-dynamic-content" class="section"><a class="anchor-link left" href="#serving-mixed-static-and-dynamic-content"><i class="icofont-laika">&#xef71;</i></a>Serving Mixed Static and Dynamic Content</h2>
            <p>The <code>SiteRoute</code> and <code>AuthorizedSiteRoute</code> traits can be used to serve content that uses a mix of dynamic
            (RACE-generated) and static (externally generated) data stored in the file system. The configuration looks like this:</p>
            <pre><code>...
actors = [...
  { name = &quot;httpServer&quot;
    class = &quot;gov.nasa.race.http.HttpServer&quot;

    host = &quot;localhost&quot;
    port = &quot;8080&quot;

    routes = [
      { name = &quot;tabdata&quot;
        class = &quot;gov.nasa.race.http.tabdata.TabDataService&quot; // SiteRoute implementor

        request-prefix = &quot;tabdata&quot; // URL path prefix for requests
        node-root = &quot;race-net-http-test/src/resources/sites/tabdata&quot; // root dir of static content
      ...</code></pre>
            <p>The <code>node-root</code> directly points to the root dir where respective route files can be found, to support
            configurations that serve content kept outside of RACE. Note that <code>request-prefix</code> (which defaults to the <code>name</code>
            value) and <code>node-root</code> can be different.</p>
            
            <h2 id="test-routes" class="section"><a class="anchor-link left" href="#test-routes"><i class="icofont-laika">&#xef71;</i></a>Test Routes</h2>
            <p>To test network connection and client compatibility the <code>race-net-http</code> module provides a number of generic
            RacRouteInfo examples:</p>
            <ul>
              <li><code>TestRouteInfo</code> serves a single configurable response in response to a GET. Clients can be browsers or
              command line utilities such as <code>curl</code>. The <code>http-server.conf</code> configuration shows how to use this route
              (via <code>https://localhost:8080/hello</code> requests)</li>
              <li><code>TestAuthorized</code> is an example that requires interactive user authentication by means of a browser client. The
              server will automatically respond with a login dialog the first time the user requests that page. The
              <code>http-server.conf</code> includes a <code>https://localhost:8080/secret</code> route to demonstrate.</li>
              <li><code>TestPreAuthorized</code> requires automated login via a POST with respective user credentials before accessing the
              content. Use <code>http-server.conf</code> together with a <code>gov.nasa.race.http.HttpImportActor</code> (e.g. <code>preauth-client.conf</code>)
              to run</li>
              <li><code>TestPusher</code> and <code>TestAuthorizedPusher</code> are websocket examples to be used with the <code>ws-server.conf</code> and
              <code>ws-auth-server.conf</code> configurations. The first one can be used with a web socket command line client such as
              <code>wscat</code>, the second one requires a browser to enter user credentials. As the names imply both examples push data
              from RACE to all connected clients</li>
              <li><code>EchoService</code> (and <code>ws-echo,conf</code>) is an examples that shows how to use connection specific request/response,
              as opposed to push mode which sends the same data to all connected clients</li>
              <li><code>TabDataService</code> is the most comprehensive example that shows how to use RACE to serve a node which
              uses websockets to push dynamic data to connected clients. This works with normal browser clients (using http)</li>
            </ul>
        </div>

    </body>
</html>