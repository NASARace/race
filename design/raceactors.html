<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8"/>
        <title>RACE</title>

        <link href="../race-html.css" rel="stylesheet"/>
    </head>

    <body>
        <div class="navbar">
            <div class=""banner>
                <a href="../index.html" ><img class="logo" src="../images/race128.png"></a>
                <p class="doctitle">RACE Manual</p>
            </div>
            <br/>
            <div class="toc">
                <p class="title">Project Links</p>
                <ul>
                    <li><span class="toc level2"><a href="https://github.com/NASARace/race.git">Repository</a></span></li>
                    <li><span class="toc level2"><a href="http://nasarace.github.io/race">Website</a></span></li>
                </ul>
            </div>
            <div class="toc pagetoc">
                <p class="title">Page</p>
                <ul class="nav-list">
                  <li class="level1 active"><a href="#">RaceActors</a></li>
                  <li class="level2"><a href="#state-model">State Model</a></li>
                  <li class="level2"><a href="#creation-and-initialization">Creation and Initialization</a></li>
                  <li class="level2"><a href="#separation-of-system-and-user-message-processing">Separation of System and User Message Processing</a></li>
                  <li class="level2"><a href="#publish-subscribe">Publish/Subscribe</a></li>
                  <li class="level2"><a href="#example">Example</a></li>
                </ul>
            </div>
            <div class="toc globaltoc">
                <p class="title">Site</p>
                <ul class="nav-list">
                  <li class="level1 nav-header">RACE Manual</li>
                  <li class="level2"><a href="../index.html">About RACE</a></li>
                  <li class="level2 nav-header">Installing RACE</li>
                  <li class="level3"><a href="../installation/prerequisites.html">Prerequisites</a></li>
                  <li class="level3"><a href="../installation/download.html">Downloading RACE</a></li>
                  <li class="level3"><a href="../installation/build.html">Building RACE</a></li>
                  <li class="level3"><a href="../installation/pitfalls.html">Installation Pitfalls</a></li>
                  <li class="level3"><a href="../installation/osx.html">OS X Specifics</a></li>
                  <li class="level2 nav-header">Using RACE</li>
                  <li class="level3"><a href="../usage/running.html">How to Run RACE</a></li>
                  <li class="level3"><a href="../usage/configuration.html">RACE Configuration</a></li>
                  <li class="level3"><a href="../usage/encryption.html">Using Encrypted Configurations</a></li>
                  <li class="level2 nav-header">RACE Design</li>
                  <li class="level3"><a href="overview.html">Design Overview</a></li>
                  <li class="level3"><a href="actors.html">Actors</a></li>
                  <li class="level3"><a href="configuration.html">Runtime Configuration</a></li>
                  <li class="level3 active"><a href="#">RaceActors</a></li>
                  <li class="level3"><a href="channeltopics.html">ChannelTopics</a></li>
                  <li class="level3"><a href="embedded-objects.html">Embedded Objects</a></li>
                  <li class="level3"><a href="connectivity.html">Connecting External Systems</a></li>
                  <li class="level3"><a href="remoting.html">Remote RaceActors and Distributed RACE Applications</a></li>
                  <li class="level3"><a href="remotelauncher.html">RemoteLauncher</a></li>
                  <li class="level3"><a href="hc.html">Heterogeneous Computing in RACE</a></li>
                  <li class="level3"><a href="parsing.html">RACE Parsers</a></li>
                  <li class="level3"><a href="archive-replay.html">Archive and Replay</a></li>
                  <li class="level3"><a href="timeseries.html">Time Series Analysis</a></li>
                  <li class="level3"><a href="trajectory.html">Trajectory Infrastructure</a></li>
                  <li class="level3"><a href="rgis.html">RACE GIS Support</a></li>
                  <li class="level3"><a href="worldwind.html">WorldWind Viewer</a></li>
                  <li class="level3"><a href="http-server.html">HttpServer</a></li>
                  <li class="level3"><a href="http-client.html">HttpImportActor</a></li>
                  <li class="level3"><a href="share.html">SHARE - System for Hierarchical Ad hoc Reporting</a></li>
                  <li class="level3"><a href="layers-and-modules.html">Layers and Modules</a></li>
                  <li class="level3"><a href="directory-structure.html">Directory Structure</a></li>
                  <li class="level3"><a href="repository.html">Repository Structure</a></li>
                  <li class="level3"><a href="local-build.html">Local Build Configuration</a></li>
                  <li class="level3"><a href="dds.html">RACE and DDS</a></li>
                  <li class="level3"><a href="extproject.html">Using RACE from External Projects</a></li>
                  <li class="level3"><a href="whyscala.html">Why Scala</a></li>
                  <li class="level2 nav-header">Documentation</li>
                  <li class="level3"><a href="../documentation/overview.html">RACE Documentation Overview</a></li>
                  <li class="level3"><a href="../documentation/presentations.html">Available Slide Presentations</a></li>
                  <li class="level2 nav-header">Annex</li>
                  <li class="level3"><a href="../annex/project-log.html">Project Log</a></li>
                  <li class="level3"><a href="../annex/examples.html">RACE Examples</a></li>
                  <li class="level3"><a href="../annex/known-problems.html">Known Problems</a></li>
                  <li class="level3"><a href="../annex/changes.html">Changes</a></li>
                  <li class="level3"><a href="../annex/todo.html">TODO List</a></li>
                  <li class="level3"><a href="../annex/learning.html">Learning Resources</a></li>
                  <li class="level3"><a href="../annex/glossary.html">Glossary</a></li>
                </ul>
            </div>
        </div>

        <div class="main">
            <h1 id="raceactors" class="title">RaceActors</h1>
            <p>RaceActors are specialized Akka actors that primarily implement three RACE specific aspects:</p>
            <ul>
              <li>a RACE specific state model</li>
              <li>initialization through external configuration data</li>
              <li>communication through network-enabled publish/subscribe channels</li>
            </ul>
            <p>The RACE distribution includes a number of ready-to-use RaceActors, but in general RaceActors are
            the major extension axis of RACE. To that end, special care is taken to minimize the system overhead
            in concrete RaceActor classes, and to separate processing of system messages from actor specific
            messages.</p>
            
            <h2 id="state-model" class="section"><a class="anchor-link left" href="#state-model"><i class="icofont-laika">&#xef71;</i></a>State Model</h2>
            <p>Based on the RACE runtime phases, RaceActors implement the following state model</p>
            <p><img class="left scale50" src="../images/actor-states.svg" alt="RACE overview"></p>
            <ul>
              <li><strong>Initializing</strong> - automatically set during RaceActor creation.</li>
              <li><strong>Initialized</strong> - actor has completed its dynamic initialization, i.e. has returned from its
              <code>onInitializeRaceActor()</code> method. This is triggered by a <code>InitializeRaceActor</code> message from the
              master actor.</li>
              <li><strong>Started</strong> - actor has received a <code>StartRaceActor</code> message from the master actor.</li>
              <li><strong>Running</strong> - actor has successfully returned from its <code>onStartRaceActor()</code> method.</li>
              <li><strong>Paused</strong> - actor has successfully returned from its <code>onPauseRaceActor()</code> method, which is called
              automatically when receiving a <code>PauseRaceActor</code> message from the master actor.</li>
              <li><strong>Terminating</strong> - actor has received a <code>TerminateRaceActor</code> message from the master actor.</li>
              <li><strong>Terminated</strong> - actor has returned successfully from its <code>onTerminateRaceActor()</code> method. This
              marks the end of a RaceActor lifecycle.</li>
            </ul>
            <p>All state transitions are triggered by system messages (e.g. <code>InitializeRaceActor</code>) that are sent
            by the master actor. Transition response is a message indicating either success (e.g.
            <code>RaceActorInitialized</code>) or failure (e.g. <code>RaceActorInitializeFailed</code>). All state related
            system messages are sent point-to-point between the master and the respective RaceActor, and
            are processed synchronously by the master actor. Dotted states are automatically entered/exited and supposed
            to be transient.</p>
            
            <h2 id="creation-and-initialization" class="section"><a class="anchor-link left" href="#creation-and-initialization"><i class="icofont-laika">&#xef71;</i></a>Creation and Initialization</h2>
            <p>RaceActors are created by the master actor by means of normal Akka APIs, providing a
            <a href="https://github.com/typesafehub/config">TypesafeConfig</a> object as the sole constructor argument:</p>
            <pre><code>val actorConfig: Config = ..
val actorRef = context.actorOf( Props(actorCls, actorConfig), actorName)</code></pre>
            <p>The config object is normally straight from the RACE <a href="configuration.html#runtime-configuration">Runtime Configuration</a>, but includes only the
            config element for the particular RaceActor to initialize. The constructor uses this config argument
            to initialize own and mixin (supertype) fields, e.g.:</p>
            <pre><code>import gov.nasa.race.core.PublishingRaceActor
...
class AircraftModel (val config: Config) extends PublishingRaceActor {
  val id = config.getString(&quot;id&quot;)
  ...</code></pre>
            <p>Existence of a concrete <code>config</code> field is enforced in the RACE provided traits, such as:</p>
            <pre><code>package gov.nasa.race.core
import akka.actor.Actor

trait RaceActor extends Actor ... {
   val config: Config
   ...
}
...
trait PublishingRaceActor extends RaceActor {
   .. readFrom ++= actorConf.getOptionalStringList(&quot;read-from&quot;) ..</code></pre>
            <p>RaceActor constructors only perform the first (local) initialization step. The second step takes
            place after all actors have been constructed, upon receiving a <code>InitializeRaceActor</code> message from
            the master actor. In response, the system automatically calls a <code>onInitializeRaceActor(..
actorConfig)</code> method that can be overridden by concrete RaceActor classes. For strictly local
            RaceActors the config object is the same that was passed into the constructor. For remote
            RaceActors, this is the remote configuration for this particular actor.</p>
            <p>If concrete RaceActor classes rely on functionality of mixed in system RaceActor traits, they
            should call the respective super method:</p>
            <pre><code>class AircraftModel .. extends PublishingRaceActor { ...
  override def onInitializeRaceActor(rc: RaceContext, actorConf: Config) = {
    // ..perform specific initialization..
    super.onInitializeRaceActor(rc,actorConf) // perform system initialization
 ...</code></pre>
            
            <h2 id="separation-of-system-and-user-message-processing" class="section"><a class="anchor-link left" href="#separation-of-system-and-user-message-processing"><i class="icofont-laika">&#xef71;</i></a>Separation of System and User Message Processing</h2>
            <p>Development of new RaceActors is the primary approach to extend RACE. Consequently, such new
            RaceActor classes should only have to provide application specifics, and leave general system
            processing to mixin system types.</p>
            <p>To achieve this goal, concrete actors have to mix in the <code>gov.nasa.race.core.RaceActor</code> trait,
            which basically maps system messages to methods that can - but do not have to - be overridden by
            concrete RaceActor classes. These callback methods follow the same naming pattern, which is
            derived from the respective system message (e.g. <code>StartRaceActor</code> -&gt; <code>onStartRaceActor()</code>).</p>
            <p>The standard Akka Actor <code>receive()</code> method should <em>not</em> be overridden, as it holds the processing
            that has to happen regardless of concrete RaceActor system callback implementation. Moreover, the
            <code>RaceActor</code> trait actually swaps this message handler once the <code>Initialized</code> state for this
            actor is reached, which will install a overridable <code>handleMessage()</code> as the primary message
            handler for user messages. This is the method concrete RaceActors should provide to process
            application specific messages.</p>
            <p><img class="center scale80" src="../images/race-actor-sep.svg" alt="RACE overview"></p>
            <p>The rationale for this dynamic runtime behavior change is that concrete actor fields might get their
            initial values from <code>InitializeRaceActor</code> configuration data, and hence should not be referenced
            from message handlers before the <code>Initialized</code> state is reached.</p>
            <p><strong>*CAVEAT</strong>* - unless this is really intended in order to completely replace all system message
            processing, overridden <code>handleMessage</code> methods should <strong>not</strong> have a match-all clause, such as:</p>
            <pre><code>override def handleMessage = {
  .. // user message clauses
  case other =&gt; ..</code></pre>
            <p>This would effectively cut off all RACE system message processing in core RaceActor traits.
            RACE automatically checks during initialization of a RaceActorSystem that actors which are
            initialized properly respond to system messages and automatically shuts down otherwise.</p>
            
            <h2 id="publish-subscribe" class="section"><a class="anchor-link left" href="#publish-subscribe"><i class="icofont-laika">&#xef71;</i></a>Publish/Subscribe</h2>
            <p>Although RaceActors can use normal Akka point-to-point messaging (e.g. for system messages), the
            normal data communication between RaceActors is done through a network-enabled publish/subscribe
            mechanism, which utilizes a RACE specific <code>Bus</code> object that is provided by the master during
            RaceActor initialization. This bus holds logical <code>channels</code> which are identified by means of
            path-like strings such as <code>/flights/positions</code>. The messages published to such channels are
            wrapped into <code>BusEvent</code> objects that hold the payload message, the sender (actorRef) and the
            respective channel this message was published to.</p>
            <p>Publishers get the data channels to publish to from the actor configuration, and use a <code>publish()</code>
            method provided by the <code>PublishingRaceActor</code> trait in order to write to such channels:</p>
            <pre><code>//--- RACE configuration: myuniverse.conf
... actors [ ...
     { name = ..
       class = &quot;myactors.AircraftModel&quot;
       write-to = &quot;/flights/positions&quot;
...

//--- actor implementation: AircraftModel.scala
import gov.nasa.race.core.PublishingRaceActor

class AircraftModel (val conf: Config) extends PublishingRaceActor {
  val writeTo = conf.getString(&quot;write-to&quot;)
  ...
      publish( writeTo, new FlightPosition(...))
  ...</code></pre>
            <p>Conversely, subscribers mix in the system trait <code>SubscribingRaceActor</code> (which automatically
            subscribes to configured channels during actor initialization), and pattern match for respective
            <code>BusEvents</code> in their message handlers:</p>
            <pre><code>//--- RACE configuration: myuniverse.conf
... actors [ ...
   { .. class = &quot;myactors.FlightProbe&quot;
        read-from = &quot;/flights/positions&quot;
...

//--- actor implementation: FlightProbe.scala
import gov.nasa.race.core.SubscribingRaceActor

class FlightProbe (val conf: Config) extends SubscribingRaceActor {
   ...
   override def handleMessage = { ...
     case BusEvent(channel, msg: FlightPosition, sender) =&gt; ...
  ...</code></pre>
            <p>Normally, subscribers only match on payload types (e.g. <code>FlightPosition</code>), channel (selector
            string) and sender (actorRef) are usually ignored.</p>
            <p>Channels do not have to be defined separately in the configuration, they are merely selectors
            used at runtime. This allows to subscribe to a whole tree of sub-channels by using wildcards (e.g.
            <code>/flights/*</code>).</p>
            <p>Channel names that start with <code>/local/</code> will only use the bus of the RACE process that executes
            the respective actor. Messages published to such channels will not be sent to other RACE instances.</p>
            <p>Channels are not type constrained with respect to payload messages. Channel subscribers are
            responsible for extraction of relevant payload messages, for which Scala&#39;s pattern matching is a
            very convenient and type safe mechanism.</p>
            
            <h2 id="example" class="section"><a class="anchor-link left" href="#example"><i class="icofont-laika">&#xef71;</i></a>Example</h2>
            <p>Here is a complete example that shows a RaceActor which periodically computes and publishes flight positions
            for a configured aircraft:</p>
            <pre><code>package gov.nasa.race.air.actor

import akka.actor.ActorRef
import com.typesafe.config.Config
import gov.nasa.race.air.FlightPos
import gov.nasa.race.core.RaceTick
import gov.nasa.race.core.{ContinuousTimeRaceActor, PeriodicRaceActor, PublishingRaceActor, SubscribingRaceActor}
import gov.nasa.race.geo.GreatCircle._
import gov.nasa.race.geo.LatLonPos
import gov.nasa.race.uom.Angle._
import gov.nasa.race.uom.Length._
import gov.nasa.race.uom.Speed._
import gov.nasa.race.uom._

import scala.language.postfixOps

class SimpleAircraft (val config: Config) extends ContinuousTimeRaceActor
             with SubscribingRaceActor with PublishingRaceActor with PeriodicRaceActor {

  //--- initialization from configuration
  val id = config.getString(&quot;id&quot;)
  val cs = config.getString(&quot;cs&quot;)

  // Ok to use vars here since nobody outside this actor will have access
  var pos = LatLonPos(Degrees(config.getDouble(&quot;lat&quot;)), Degrees(config.getDouble(&quot;lon&quot;)))
  var speed = Knots(config.getDouble(&quot;speed-kn&quot;))
  var altitude = Feet(config.getDouble(&quot;altitude-ft&quot;))
  var heading = Degrees(config.getDouble(&quot;heading&quot;))

  //--- overridden initialization/termination callbacks

  override def onStartRaceActor(originator: ActorRef) = {
    super.onStartRaceActor(originator)
    startScheduler
  }

  //---  user message handler
  override def handleMessage = {
    case RaceTick =&gt;
      updatePos
      debug(s&quot;publishing $pos&quot;)
      publish(FlightPos(id, cs, pos, altitude, speed, heading, simTime))
  }

  //--- internal functions

  def updatePos: Unit = {
    val dist: Length = speed * updateElapsedSimTime
    pos = endPos(pos, dist, heading, altitude)
  }
}</code></pre>
        </div>

    </body>
</html>