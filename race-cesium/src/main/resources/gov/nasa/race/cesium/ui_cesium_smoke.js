import * as config from "./config.js"; // generated by scala
import * as ws from "./ws.js";
import * as util from "./ui_util.js";
import * as ui from "./ui.js";
import * as uiCesium from "./ui_cesium.js";

// smoke entry definition
const defaultContourRender = initDefaultColors(config.smokelayer.contourRender);
var currentContourRender = initDefaultColors(config.smokelayer.contourRender);
updateColors();

const SmokeLayerType = {
    SMOKE: "smoke",
    CLOUD: "cloud"
}

const LOADED = "○";
const SHOWING = "●";

class SmokeCloudEntry {

    // factory method
    static create (smokeLayer) {
        if (smokeLayer.scType == SmokeLayerType.SMOKE) return new SmokeEntry(smokeLayer);
        if (smokeLayer.scType == SmokeLayerType.CLOUD) return new CloudEntry(smokeLayer);
    }

    constructor(smokeLayer) {
        // come from server message
        this.date = smokeLayer.date // date and time from data
        this.type = smokeLayer.scType // smoke or cloud
        this.satellite = smokeLayer.satellite // satellite from data
        this.srs = smokeLayer.srs // srs from data
        this.url = smokeLayer.url // where to get data
        this.dataSource = undefined;
        this.render = {...currentContourRender};
    }

    setStatus (newStatus) {
        this.status = newStatus;
        // update view
    }

    replaceWith (other) {
        console.log("not yet.");
    }

    SetVisible (showIt) { // needs to fetch the contours
        if (showIt != this.show) {
            this.show = showIt;
            if (showIt) {
                if (!this.dataSource) {
                    this.loadContoursFromUrl(); // this is async, it will set vectorPrimitives when done
                } else {
                    this.dataSource.show = true;
                    uiCesium.requestRender();
                }
                this.setStatus( SHOWING);

            } else {
                if (this.dataSource) {
                    this.dataSource.show = false;
                    uiCesium.requestRender();
                    this.setStatus( LOADED);
                }
            }
        }
    }

    async loadContoursFromUrl() { // handles new data source
        let renderOpts = this.getRenderOpts(); //
        let response = await fetch(this.url);
        let data = await response.json();
        console.log(data);
        Cesium.GeoJsonDataSource.load(data, renderOpts).then(  // TODO - does this support streams?
            ds => {
                this.dataSource = ds;
                this.postProcessDataSource();
                uiCesium.addDataSource(ds);
                uiCesium.requestRender();
            }
        );
    }

    getRenderOpts() {
        return { // could add a poly line
            stroke: this.render.strokeColor,
            strokeWidth: this.render.strokeWidth,
            //fill: this.render.fillColors[0],
            alpha: this.render.alpha,
            clampToGround: false
        };
    }

    postProcessDataSource() {
        let entities = this.dataSource.entities.values;
        let render = this.render;
        for (const e of entities) {
            let props = e.properties;
            if (props) {
                let prob = this.getPropValue(props, "prob");
                if (prob!== null) {
                    let i = prob; // prob-1 for binary polygons
                    //console.log(i, this.render.fillColors[i]);
                    e.polygon.material = this.render.fillColors[i];
                    e.polygon.outline = true;
                    e.polygon.outlineColor = this.render.strokeColor;
                    e.polygon.outlineWidth = this.render.strokeWidth;
                }
            }
        }
    }

    getPropValue(props,key) {
        let p = props[key];
        return p ? p._value : undefined;
    }

    updateDisplayPanel() {
        console.log("Selected")
        let render = this.render;
    }

    renderChanged() {
        this.render = {...currentContourRender};
        this.getRenderOpts();
        if (this.dataSource) {
            this.postProcessDataSource();
            uiCesium.requestRender();
        }
    }
}

class SmokeEntry extends SmokeCloudEntry {
    constructor (smokeLayer) {
        super(smokeLayer)
        this.smokeFile = smokeLayer.smokeFile
    }
}

class CloudEntry extends SmokeCloudEntry {
    constructor (smokeLayer) {
        super(smokeLayer)
        this.cloudFile = smokeLayer.cloudFile
    }
}

// initialization

const smokeCloudEntries = new Map(); // unique-key -> SmokeCloudEntries
var displayEntries = [];
var selectedEntry = undefined;
var selectedType = ["smoke", "cloud"];
var selectedSat = ["G16", "G17", "G18"];
var followLatest = config.smokelayer.followLatest;

initWindow();

initCheckBoxes();

var entryView = initEntryView();

initContourDisplayControls();

ws.addWsHandler(handleWsSmokeLayerMessages);

//--- end module init
function initWindow() {
    createIcon();
    createWindow();
    console.log("ui_cesium_smokelayer initialized");
}

function createIcon() {
    console.log("created smoke icon");
    return ui.Icon("smoke-icon.svg", (e)=> ui.toggleWindow(e,'smoke'));
}

function initCheckBoxes() {
    ui.setCheckBox("smoke.followLatest", followLatest);
    ui.setCheckBox("smoke.showSmoke", selectedType.includes("smoke"));
    ui.setCheckBox("smoke.showCloud", selectedType.includes("cloud"));
    ui.setCheckBox("smoke.G16", selectedSat.includes("G16"));
    ui.setCheckBox("smoke.G17", selectedSat.includes("G17"));
    ui.setCheckBox("smoke.G18", selectedSat.includes("G18"));
}

function initEntryView() {
    let view = ui.getList("smokelayer.entries");
    if (view) {
        ui.setListItemDisplayColumns(view, ["header"], [
            { name: "type", tip: "type of entry", width: "5rem", attrs: [], map: e => e.type },
            { name: "sat", tip: "name of satellite", width: "3rem", attrs: [], map: e => e.satellite },
            { name: "date", width: "8rem", attrs: ["fixed", "alignRight"], map: e => util.toLocalMDHMString(e.date)},
        ]);
    }
    return view;
}

function createWindow() {
    return ui.Window("Smoke and Cloud Layers", "smoke", "smoke-icon.svg")(
        ui.Panel("Data Selection", true)(
            ui.RowContainer()(
                ui.CheckBox("show smoke", selectSmokeEntries, "smoke.showSmoke"), // label, function on click, value to follow
                ui.CheckBox("show cloud", selectCloudEntries, "smoke.showCloud"),
            ),
            ui.RowContainer()(
                ui.CheckBox("G16", selectSatellite, "smoke.G16"),
                ui.CheckBox("G17", selectSatellite, "smoke.G17"),
                ui.CheckBox("G18", selectSatellite, "smoke.G18"),
            ),
            ui.RowContainer()(
                ui.CheckBox("follow latest", toggleFollowLatest, "smoke.followLatest"),
                ui.Button("clear", clearSelections)
            ),
            ui.List("smokelayer.entries", 6, selectSmokeCloudEntry)
        ),
        ui.Panel("Contour Display")(
                ui.Button("reset", resetDisplaySelections),
                ui.Slider("alpha", "smoke.contour.alpha", contourAlphaChanged),
                ui.Slider("stroke width", "smoke.contour.stroke_width", contourStrokeWidthChanged),
                ui.ColorField("stroke color", "smoke.contour.stroke_color", true, contourStrokeColorChanged),
                ui.ColorField("0<p<0.25", "smoke.contour.color0", true, contourFillColorChanged),
                ui.ColorField("0.25<p<0.5", "smoke.contour.color1", true, contourFillColorChanged),
                ui.ColorField("0.5<p<0.75", "smoke.contour.color2", true, contourFillColorChanged),
                ui.ColorField("0.75<p<1", "smoke.contour.color3", true, contourFillColorChanged),
                ui.ColorField("p=1", "smoke.contour.color4", true, contourFillColorChanged),
        ),
    );
 }

function initContourDisplayControls() {
     let s = ui.getSlider("smoke.contour.alpha");
     ui.setSliderRange(s, 0, 1.0, 0.1);
     ui.setSliderValue(s, defaultContourRender.alpha);

     var e = undefined;

     e = ui.getSlider("smoke.contour.stroke_width");
     ui.setSliderRange(e, 0, 3, 0.5);
     ui.setSliderValue(e, defaultContourRender.strokeWidth);

     e = ui.getField("smoke.contour.stroke_color");
     ui.setField(e, defaultContourRender.strokeColor.toCssHexString());
     for (var i = 0; i<defaultContourRender.fillColors.length; i++) {
         e = ui.getField(`smoke.contour.color${i}`);
         if (e) {
             ui.setField(e, defaultContourRender.fillColors[i].toCssHexString().slice(0, 7));
         }
     }
}

//--- contour controls
function initDefaultColors(renderConfig) {
    let width = renderConfig.strokeWidth;
    let strokeColor = renderConfig.strokeColor;
    let alpha = renderConfig.alpha;
    let fillColors = [...renderConfig.fillColors];
    let result = {strokeWidth:width, strokeColor:strokeColor, fillColors: fillColors, alpha:alpha};
    return result
}

function contourStrokeWidthChanged(event) {
    let e = ui.getSelectedListItem(entryView);
    if (e) {
        let n = ui.getSliderValue(event.target);
        currentContourRender.strokeWidth = n;
        e.renderChanged();
    }
}

function contourStrokeColorChanged(event) {
    let e = ui.getSelectedListItem(entryView);
    if (e) {
        let clrSpec = event.target.value;
        if (clrSpec) {
            currentContourRender.strokeColor =  convertColorToHaveAlpha(clrSpec, currentContourRender.alpha);
            e.renderChanged();
        }
    }
}

function contourFillColorChanged(event) {
    let e = ui.getSelectedListItem(entryView);
    if (e) {
        let clrSpec = event.target.value;
        let boxSpec = event.target.id;
        let i =  parseInt(event.target.id.slice(-1));
        if (clrSpec) {
            currentContourRender.fillColors[i] = convertColorToHaveAlpha(clrSpec, currentContourRender.alpha);
            e.renderChanged();
        }
    }
    updateColors();
    uiCesium.requestRender();
}

function convertColorToHaveAlpha(color, alpha){
    return Cesium.Color.fromAlpha(Cesium.Color.fromCssColorString(color.slice(0,7)), alpha);
}

function convertColorToStripAlpha(color) {
    return color.toCssHexString().slice(0,7)
}

// interactions - behavior for clicking boxes and filtering entries

function updateColors(){
    for (var i = 0; i<currentContourRender.fillColors.length; i++) {
        let color = currentContourRender.fillColors[i]; // get color
        let colorNoAlpha = convertColorToStripAlpha(color); // strip current alpha
        currentContourRender.fillColors[i] =  convertColorToHaveAlpha(colorNoAlpha, currentContourRender.alpha); //add color with new alpha
    }
}

function contourAlphaChanged(event) {
    let v = ui.getSliderValue(event.target);
    currentContourRender.alpha = v;
    // update colors with new alpha
    updateColors();
    let e = ui.getSelectedListItem(entryView);
    if (e) {
        e.renderChanged();
    }
}

function resetDisplaySelections(event) {
    currentContourRender = initDefaultColors(config.smokelayer.contourRender);
    updateColors();
    initContourDisplayControls();
    selectedEntry = ui.getSelectedListItem(entryView);
    if (selectedEntry) {
        selectedEntry.renderChanged();
    }

}

function clearSelections(event){
    // clear viewed data
    selectedEntry = ui.getSelectedListItem(entryView);
    if (selectedEntry) selectedEntry.SetVisible(false);
    // clear all checkboxes
    followLatest = false;
    updateEntryView();
    initCheckBoxes();
}

function toggleFollowLatest(event) {
    followLatest = ui.isCheckBoxSelected(event.target);
    if (followLatest && ui.getSelectedListItemIndex(entryView) != 0) {
        ui.selectFirstListItem(entryView);
    }
}

function selectSmokeCloudEntry(event) { // does this need update display panel and set visible?
    selectedEntry = ui.getSelectedListItem(entryView);
    if (selectedEntry) selectedEntry.SetVisible(true);//.updateDisplayPanel(); // probably not needed for this case
}

function selectCloudEntries(event) {
    if (ui.isCheckBoxSelected(event.target)){
        if (!selectedType.includes("cloud")) selectedType.push("cloud");
    }
    else {
        var index = selectedType.indexOf("cloud");
        if (index > -1) {
            selectedType.splice(index, 1);
        }
    }
    updateEntryView();
}

function selectSatellite(event) {
    let cb = ui.getCheckBox(event.target);
    let satName = ui.getCheckBoxLabel(cb)
    if (ui.isCheckBoxSelected(event.target)){
        if (!selectedSat.includes(satName)) selectedSat.push(satName);
    }
    else {
        var index = selectedSat.indexOf(satName);
        if (index > -1) {
            selectedSat.splice(index, 1);
        }
    }
    updateEntryView();
}

function selectSmokeEntries(event) {
    if (ui.isCheckBoxSelected(event.target)){
            if (!selectedType.includes("smoke")) selectedType.push("smoke");
        }
    else {
        var index = selectedType.indexOf("smoke");
        if (index > -1) {
            selectedType.splice(index, 1);
        }
    }
    updateEntryView();
}

function updateEntryView() {
    displayEntries = util.filterMapValues(smokeCloudEntries, se=> isSelected(se));
    displayEntries.sort(SmokeCloudEntry.compareFiltered);
    ui.setListItems(entryView, displayEntries);
}

function isSelected (se) {
    return (selectedType.includes(se.type) && selectedSat.includes(se.satellite));
}

// websocket messages

function handleWsSmokeLayerMessages(msgType, msg) {
    switch (msgType) {
        case "smokeLayer":
            handleSmokeLayerMessage(msg.smokeLayer);
            return true;
        default:
            return false;
        }
}

function handleSmokeLayerMessage(smokeLayer) {
    let se = SmokeCloudEntry.create(smokeLayer);
    smokeCloudEntries.set(smokeLayer.url, se);
    if (isSelected(se)) updateEntryView();
    if (followLatest) {
            ui.selectFirstListItem(entryView)
    }
}

