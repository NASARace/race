HttpServer
==========
One of the use cases of RACE is to analyze large data streams and make results available online,
i.e. outside of RACE. To support external clients RACE includes the ``gov.nasa.race.http.HttpServer``,
which is a low- to mid-level traffic web server that can be configured with ``RaceRouteInfo`` objects,
to turn data received from RACE channels into web content and map it to URIs, supporting dynamic refresh,
user authentication, logging and more.

To that end ``HttpServer`` has two major functions:

* routing - mapping trees of URIs to content and http methods)
* content management - creating and retrieving web content

For routing ``HttpServer`` leans heavily on the AkkaHttp_ library, which provides a full
DSL_ to hierarchically define URI systems with interspersed processing elements such as
HTTP_ method matchers, cookie checks and path combinators. The DSL itself is beyond the scope of this
document,nhere we just note that each configured ``RaceRoutInfo`` can provide its own ``route()``
method that returns a ``akka.http.scaladsl.server.Route`` object.

.. image:: ../images/http-server.svg
    :class: center scale90
    :alt: HttpServer

``RaceRouteInfo`` is the construct that ties data acquisition, content creation and content/route
association together. Each ``HttpServer`` instance can be configured with any number of
``RaceRouteInfo`` objects, which in turn can have their own configuration parameters. The design is
similar to ``RaceViewerActor`` and ``RaceLayerInfos`` (see `WorldWind Viewer`_).

Data acquisition required to generate query responses is handled through dedicated actors that are
associated with their corresponding ``RaceRouteInfos``. Such actors extend ``SubscribingRaceActor``
and turn data received from the subscribed channels into ``HttpContent`` objects (aggregation of
HTML page and associated resources such as images etc.). The ``HttpContent`` is stored in
``RaceRouteInfo`` and referenced from within its ``route()`` method to generate the response for
valid HTTP requests.

There is no restriction what type of content can be supported by ``RaceRouteInfos`` (html, json
etc.). For HTML content creation we use the ScalaTags_ library, which provides a DSL that supports
procedural elements in a tree that is very close to the created HTML structure. Akka-http also
supports bi-directional communication by means of WebSockets_.


The ``gov.nasa.race.http.Test{RouteInfo,Authorized,Refresh}`` examples show how define routes and
(self refreshing) HTML content.::

    //--- basic RaceRouteInfo example
    class TestRouteInfo (val parent: ParentContext, val config: Config) extends RaceRouteInfo {
      val request = config.getStringOrElse("request", "test")
      val response = config.getStringOrElse("response", "Hello from RACE")

      override def route = {
        path(request) {
          get {
            complete(HttpEntity(ContentTypes.`text/html(UTF-8)`, response))
          }
        }
      }
    }

    //--- example of how to implement authorized content for configured paths
    class TestAuthorized (val parent: ParentContext, val config: Config) extends AuthorizedRaceRoute {
      val request = config.getStringOrElse("request", "secret")
      var count = 0
      def page = html(
        body(
          p(s"the supersecret answer #$count to the ultimate question of life, the universe and everything is:"),
          p(b("42")),
          p("(I always knew there was something wrong with the universe)"),
          logoutLink
        )
      )

      override def route = {
        path(request) {
          get {
            count += 1
            completeAuthorized(User.UserRole, HttpEntity(ContentTypes.`text/html(UTF-8)`, page.render))
          }
        }
      }
    }


Encrypted Content
-----------------
``HttpServer`` can be configured to use the HTTPS_ protocol for server authentication and
content encryption::

    ...
    use-https = true
    server-keystore = "??server.keystore"
    server-keystore-pw = "??server.pw"
    ...

If ``use-https`` is set a valid `X.509 certificate`_ keystore has to be provided, which can for
instance be generated by means of the JDK keytool_. Location path and passphrase values should be kept
in a vault (see `Encrypted Configurations`_) like this::

    ...
    server {
        keystore="../cert/localhost.jks"
        pw="mysupersecretpassphrase"
        ...
    }

For testing purposes a keystore can be created by running the ``script/gen-server-cert.sh`` script.
To generate a self-signed CA certificate we provide ``script/gen-ca-cert.sh``.


User Authentication
-------------------
If content requires user authentication the respective ``RaceRouteInfo`` can be derived from
``AuthorizedRaceRoute`` or ``AutoAuthorizedRaceRoute``, which both provide a ``completeAuthorized``
directive that is used instead of ``complete`` when defining the route::

    ...
    override def route = {
      path("secretData") {
        get {
          completeAuthorized(User.UserRole){
            generateResponse
          }
        }
      }
    }

``AuthorizedRaceRoute`` is used for interactive clients and automatically redirects to/from a
login web page the first time the content is accessed. ``AutoAuthorizedRaceRoute`` is for automated,
non-interactive web clients and requires explicit login/logout requests from the client application.

User authentication is done by means of challenge/response cookies, i.e. after successful user
login ``HttpServer`` transmits a cookie in the response (via ``Set-Cookie`` header) that has to
be included in the next request from the client. Each accepted response yields a new cookie value,
i.e. each cookie is only good for the next request and is not permanently stored on the client side:

.. image:: ../images/server-auth.svg
    :class: center scale90
    :alt: server side user authentication

A session cookie can also have an expiration date after which the ``HttpServer`` will reject it.

User authentication requires an additional ``user-auth`` route configuration option to specify the
respective password store to use::

    ...
    use-https = true
    server-keystore = "??server.keystore"
    server-keystore-pw = "??server.pw"

    routes = [
      ...
      { name = "secretData"
        class = "gov.nasa.race.http.TestAutoAuthorized"
        request = "secretData"
        user-auth = "??server.users"
      }
    ]

Again, the value for this option should be kept in a encrypted config. Since the password is
transmitted in the login request data respective routes have to use https.

This user authentication protocol is also supported by the HttpImportActor_

.. _HTTP: https://tools.ietf.org/html/rfc2616
.. _HTTPS: https://en.wikipedia.org/wiki/HTTPS
.. _AkkaHttp: https://doc.akka.io/docs/akka-http/current/scala/http/
.. _DSL: https://doc.akka.io/docs/akka-http/current/scala/http/routing-dsl/index.html
.. _ScalaTags: http://www.lihaoyi.com/scalatags/
.. _WebSockets: https://doc.akka.io/docs/akka-http/current/server-side/websocket-support.html
.. _X.509 certificate: https://lightbend.github.io/ssl-config/CertificateGeneration.html
.. _keytool: https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html